# GitLab CI Generic Template for AsciiDoc Documentation Projects
# This template provides a flexible, reusable pipeline for any AsciiDoc-based documentation

# YAML Anchors for reusability
.ruby_setup: &ruby_setup
  image: ruby:3.2
  before_script:
    - gem install bundler
    - bundle config set --local path 'vendor/bundle'
    - bundle install

.asciidoctor_setup: &asciidoctor_setup
  image: asciidoctor/docker-asciidoctor:latest
  before_script:
    - mkdir -p ${BUILD_DIR}
    - echo "Processing ${DOCUMENT_FILE}"

.docker_setup: &docker_setup
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker info

.artifact_policy: &artifact_policy
  artifacts:
    name: "${OUTPUT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${BUILD_DIR}/
    expire_in: ${ARTIFACT_EXPIRATION}
    reports:
      dotenv: build.env

.short_expiration: &short_expiration
  artifacts:
    name: "${OUTPUT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${BUILD_DIR}/
    expire_in: 3 days

.long_expiration: &long_expiration
  artifacts:
    name: "${OUTPUT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${BUILD_DIR}/
    expire_in: 30 days

.permanent_artifacts: &permanent_artifacts
  artifacts:
    name: "${OUTPUT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
    paths:
      - ${BUILD_DIR}/
    expire_in: never

.branch_rules: &branch_rules
  only:
    - branches
    - tags
    - merge_requests

.master_rules: &master_rules
  only:
    - master
    - main
    - tags

.feature_rules: &feature_rules
  only:
    - /^feature\/.*/
    - /^bugfix\/.*/
    - merge_requests

.tag_rules: &tag_rules
  only:
    - tags

# Default variables - override these in your project
variables:
  DOCUMENT_FILE: "icd-template.adoc"
  OUTPUT_NAME: "document"
  BUILD_DIR: "build"
  ARTIFACT_EXPIRATION: "7 days"
  ENABLE_VERIFY: "true"
  ENABLE_BUILD: "true"
  ENABLE_DEPLOY: "false"

# Pipeline stages
stages:
  - verify
  - build
  - deploy

# Verify Stage - Syntax and structure validation
verify:syntax:
  <<: *ruby_setup
  <<: *branch_rules
  stage: verify
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
  script:
    - echo "Verifying syntax for ${DOCUMENT_FILE}"
    - |
      if [ -f "Makefile" ]; then
        bundle exec make verify || echo "Make verify not available, skipping"
      else
        bundle exec asciidoctor --version
        bundle exec asciidoctor ${DOCUMENT_FILE} --safe-mode secure --no-header-footer -o /dev/null
      fi
    - echo "Syntax verification completed"
  cache:
    key: ${CI_COMMIT_REF_SLUG}-gems
    paths:
      - vendor/bundle
  rules:
    - if: '$ENABLE_VERIFY == "true"'

verify:links:
  <<: *asciidoctor_setup
  <<: *branch_rules
  stage: verify
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
  script:
    - echo "Validating links and cross-references in ${DOCUMENT_FILE}"
    - mkdir -p ${BUILD_DIR}/reports
    - |
      echo "Checking for broken cross-references..."
      if grep -oE '<<[^>]+>>' ${DOCUMENT_FILE} > ${BUILD_DIR}/reports/cross-refs.log; then
        echo "Found $(wc -l < ${BUILD_DIR}/reports/cross-refs.log) cross-references"
      else
        echo "No cross-references found"
      fi
    - echo "Link validation completed"
  artifacts:
    paths:
      - ${BUILD_DIR}/reports/
    expire_in: 7 days
  allow_failure: true
  rules:
    - if: '$ENABLE_VERIFY == "true"'

# Build Stage - Generate outputs in multiple formats
build:pdf:
  <<: *asciidoctor_setup
  <<: *branch_rules
  stage: build
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Generating PDF from ${DOCUMENT_FILE}"
    - mkdir -p ${BUILD_DIR}/logs
    - |
      asciidoctor-pdf ${DOCUMENT_FILE} \
        -o ${BUILD_DIR}/${OUTPUT_NAME}.pdf \
        -a allow-uri-read \
        -a pdf-theme=default \
        -a source-highlighter=rouge \
        2>&1 | tee ${BUILD_DIR}/logs/pdf-build.log
    - ls -lh ${BUILD_DIR}/${OUTPUT_NAME}.pdf
    - echo "PDF_OUTPUT=${BUILD_DIR}/${OUTPUT_NAME}.pdf" >> build.env
    - echo "BUILD_TIME=$(date +%Y-%m-%dT%H:%M:%S)" >> build.env
  needs:
    - job: verify:syntax
      optional: true
  <<: *artifact_policy
  rules:
    - if: '$ENABLE_BUILD == "true"'

build:html:
  <<: *asciidoctor_setup
  <<: *branch_rules
  stage: build
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Generating HTML from ${DOCUMENT_FILE}"
    - mkdir -p ${BUILD_DIR}/logs
    - |
      asciidoctor ${DOCUMENT_FILE} \
        -o ${BUILD_DIR}/${OUTPUT_NAME}.html \
        -a allow-uri-read \
        -a source-highlighter=rouge \
        -a toc=left \
        -a toclevels=3 \
        -a sectanchors \
        2>&1 | tee ${BUILD_DIR}/logs/html-build.log
    - ls -lh ${BUILD_DIR}/${OUTPUT_NAME}.html
    - echo "HTML_OUTPUT=${BUILD_DIR}/${OUTPUT_NAME}.html" >> build.env
    - echo "BUILD_TIME=$(date +%Y-%m-%dT%H:%M:%S)" >> build.env
  needs:
    - job: verify:syntax
      optional: true
  <<: *artifact_policy
  rules:
    - if: '$ENABLE_BUILD == "true"'

build:docbook:
  <<: *asciidoctor_setup
  <<: *branch_rules
  stage: build
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Generating DocBook from ${DOCUMENT_FILE}"
    - mkdir -p ${BUILD_DIR}/logs
    - |
      asciidoctor ${DOCUMENT_FILE} \
        -b docbook \
        -o ${BUILD_DIR}/${OUTPUT_NAME}.xml \
        -a allow-uri-read \
        2>&1 | tee ${BUILD_DIR}/logs/docbook-build.log
    - ls -lh ${BUILD_DIR}/${OUTPUT_NAME}.xml
    - echo "DOCBOOK_OUTPUT=${BUILD_DIR}/${OUTPUT_NAME}.xml" >> build.env
  needs:
    - job: verify:syntax
      optional: true
  <<: *artifact_policy
  allow_failure: true
  when: manual
  rules:
    - if: '$ENABLE_BUILD == "true"'

# Build Stage - Matrix strategy for multiple configurations
build:matrix:
  <<: *asciidoctor_setup
  <<: *branch_rules
  stage: build
  parallel:
    matrix:
      - DOCUMENT_FILE: ["icd-template.adoc"]
        OUTPUT_NAME: ["document"]
        FORMAT: ["pdf", "html", "docbook"]
        THEME: ["default", "custom"]
  variables:
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Building ${DOCUMENT_FILE} as ${OUTPUT_NAME}-${THEME}.${FORMAT}"
    - mkdir -p ${BUILD_DIR}/logs
    - |
      OUTPUT_FILE="${OUTPUT_NAME}-${THEME}.${FORMAT}"
      case "${FORMAT}" in
        pdf)
          asciidoctor-pdf ${DOCUMENT_FILE} \
            -o ${BUILD_DIR}/${OUTPUT_FILE} \
            -a allow-uri-read \
            -a pdf-theme=${THEME} \
            2>&1 | tee ${BUILD_DIR}/logs/${OUTPUT_NAME}-${THEME}-pdf.log
          ;;
        html)
          asciidoctor ${DOCUMENT_FILE} \
            -o ${BUILD_DIR}/${OUTPUT_FILE} \
            -a allow-uri-read \
            -a stylesheet=${THEME}.css \
            2>&1 | tee ${BUILD_DIR}/logs/${OUTPUT_NAME}-${THEME}-html.log
          ;;
        docbook)
          asciidoctor ${DOCUMENT_FILE} \
            -b docbook \
            -o ${BUILD_DIR}/${OUTPUT_FILE%.${FORMAT}}.xml \
            -a allow-uri-read \
            2>&1 | tee ${BUILD_DIR}/logs/${OUTPUT_NAME}-${THEME}-docbook.log
          ;;
      esac
    - ls -lh ${BUILD_DIR}/${OUTPUT_NAME}-${THEME}.*
    - echo "OUTPUT_FILE=${BUILD_DIR}/${OUTPUT_FILE}" >> build.env
  needs:
    - job: verify:syntax
      optional: true
  <<: *artifact_policy
  when: manual
  rules:
    - if: '$ENABLE_BUILD == "true"'

# Build with Docker
build:docker:
  <<: *docker_setup
  <<: *branch_rules
  stage: build
  variables:
    DOCUMENT_FILE: "${DOCUMENT_FILE}"
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Building ${DOCUMENT_FILE} using Docker"
    - mkdir -p ${BUILD_DIR}
    - |
      docker run --rm \
        -v $(pwd):/documents \
        asciidoctor/docker-asciidoctor:latest \
        asciidoctor-pdf ${DOCUMENT_FILE} -o ${BUILD_DIR}/${OUTPUT_NAME}.pdf
    - |
      docker run --rm \
        -v $(pwd):/documents \
        asciidoctor/docker-asciidoctor:latest \
        asciidoctor ${DOCUMENT_FILE} -o ${BUILD_DIR}/${OUTPUT_NAME}.html
    - ls -lh ${BUILD_DIR}/
  <<: *artifact_policy
  allow_failure: true
  when: manual
  rules:
    - if: '$ENABLE_BUILD == "true"'

# Deploy Stage - Flexible deployment options
deploy:pages:
  stage: deploy
  <<: *master_rules
  image: alpine:latest
  variables:
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Preparing for GitLab Pages deployment"
    - mkdir -p public
    - cp ${BUILD_DIR}/${OUTPUT_NAME}.html public/index.html
    - cp ${BUILD_DIR}/${OUTPUT_NAME}.pdf public/ || echo "PDF not available"
    - ls -lh public/
  artifacts:
    paths:
      - public
    expire_in: never
  dependencies:
    - build:html
    - build:pdf
  when: manual
  rules:
    - if: '$ENABLE_DEPLOY == "true"'

deploy:artifacts:
  stage: deploy
  <<: *master_rules
  image: alpine:latest
  variables:
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Deploying ${OUTPUT_NAME} artifacts"
    - ls -lh ${BUILD_DIR}/
    - echo "Customize this job for your deployment target"
    - |
      echo "Available for deployment:"
      find ${BUILD_DIR} -type f -name "${OUTPUT_NAME}.*"
  dependencies:
    - build:pdf
    - build:html
  when: manual
  rules:
    - if: '$ENABLE_DEPLOY == "true"'
  environment:
    name: production
    action: start

# Branch-specific artifact management
deploy:archive:feature:
  stage: deploy
  <<: *feature_rules
  image: alpine:latest
  variables:
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Archiving feature branch build"
    - echo "Branch: ${CI_COMMIT_REF_NAME}"
  dependencies:
    - build:pdf
    - build:html
  <<: *short_expiration
  when: manual

deploy:archive:release:
  stage: deploy
  <<: *tag_rules
  image: alpine:latest
  variables:
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Archiving release build"
    - echo "Tag: ${CI_COMMIT_TAG}"
    - mkdir -p ${BUILD_DIR}/release
    - |
      cat > ${BUILD_DIR}/release/README.txt << EOF
      Release: ${CI_COMMIT_TAG}
      Document: ${OUTPUT_NAME}
      Build Date: $(date)
      Pipeline: ${CI_PIPELINE_URL}
      EOF
  dependencies:
    - build:pdf
    - build:html
  <<: *permanent_artifacts
  when: manual

deploy:archive:master:
  stage: deploy
  <<: *master_rules
  image: alpine:latest
  variables:
    OUTPUT_NAME: "${OUTPUT_NAME}"
    BUILD_DIR: "${BUILD_DIR}"
  script:
    - echo "Archiving master branch build"
    - echo "Commit: ${CI_COMMIT_SHORT_SHA}"
    - mkdir -p ${BUILD_DIR}/archive
    - |
      cat > ${BUILD_DIR}/archive/metadata.json << EOF
      {
        "document": "${OUTPUT_NAME}",
        "branch": "${CI_COMMIT_REF_NAME}",
        "commit": "${CI_COMMIT_SHA}",
        "short_sha": "${CI_COMMIT_SHORT_SHA}",
        "build_date": "$(date -Iseconds)",
        "pipeline_id": "${CI_PIPELINE_ID}",
        "pipeline_url": "${CI_PIPELINE_URL}"
      }
      EOF
    - cat ${BUILD_DIR}/archive/metadata.json
  dependencies:
    - build:pdf
    - build:html
  <<: *long_expiration
  when: manual
